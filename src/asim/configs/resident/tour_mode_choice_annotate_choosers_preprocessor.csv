Description,Target,Expression,
#,,,
local,_DF_IS_TOUR,'tour_type' in df.columns,
,number_of_participants,df.number_of_participants if _DF_IS_TOUR else 1,
,is_joint,(df.tour_category=='joint') if _DF_IS_TOUR else False,
#,,,
# TVPB,,,
#,,,
,demographic_segment,df.income_segment.map(TVPB_demographic_segments_by_income_segment),
,c_ivt_for_segment,"np.where(demographic_segment==C_LOW_INCOME_SEGMENT_ID,c_ivt_low_income, c_ivt_high_income)",
,c_cost_for_segment,"np.where(demographic_segment==C_LOW_INCOME_SEGMENT_ID,c_cost_low_income, c_cost_high_income)",
#,,,
 local,_HAVE_PARENT_TOURS,'parent_tour_id' in df.columns,
,_parent_tour_mode,"reindex(tours.tour_mode, df.parent_tour_id) if _HAVE_PARENT_TOURS else ''",
,work_tour_is_drive,"_parent_tour_mode.isin(['DRIVEALONEFREE','DRIVEALONEPAY'])",
,work_tour_is_bike,_parent_tour_mode=='BIKE',
,work_tour_is_SOV,"_parent_tour_mode.isin(['DRIVEALONEFREE','DRIVEALONEPAY'])",
#,,,
,is_mandatory,(df.tour_category=='mandatory') if 'tour_category' in df.columns else False,
,is_joint,(df.tour_category=='joint') if 'tour_category' in df.columns else False,
,is_indiv,~is_joint,
,is_atwork_subtour,(df.tour_category=='atwork') if 'tour_category' in df.columns else False,
,is_escort,(df.tour_type == 'escort') if _DF_IS_TOUR else False,
# FIXME why inverse of value of time? need better name?,,,
#,c_cost,(0.60 * coef_ivt) / df.value_of_time,
# ivot * (c_ivt_cost_multiplier * c_ivt),,,
,ivot,1.0 / df.value_of_time,
#,,,
,dest_topology,"reindex(land_use.TOPOLOGY, df[dest_col_name])",
,terminal_time,"reindex(land_use.TERMINAL, df[dest_col_name])",
,dest_density_index,"reindex(land_use.density_index, df[dest_col_name])",
# FIXME no transit subzones for ONE_ZONE version, so all zones short walk to transit,,
,_origin_distance_to_transit,"reindex(land_use.access_dist_transit, df[orig_col_name]) if 'access_dist_transit' in land_use else shortWalk",
,_destination_distance_to_transit,"reindex(land_use.access_dist_transit, df[dest_col_name]) if 'access_dist_transit' in land_use else shortWalk",
,walk_transit_available,(_origin_distance_to_transit > 0) & (_destination_distance_to_transit > 0),
,drive_transit_available,(_destination_distance_to_transit > 0) & (df.auto_ownership > 0),
,origin_walk_time,_origin_distance_to_transit*60/walkSpeed,
,destination_walk_time,_destination_distance_to_transit*60/walkSpeed,
# RIDEHAIL,,,
,origin_density_measure,"(reindex(land_use.TOTPOP, df[orig_col_name]) + reindex(land_use.TOTEMP, df[orig_col_name])) / (reindex(land_use.TOTACRE, df[orig_col_name]) / 640)",
,dest_density_measure,"(reindex(land_use.TOTPOP, df[dest_col_name]) + reindex(land_use.TOTEMP, df[dest_col_name])) / (reindex(land_use.TOTACRE, df[dest_col_name]) / 640)",
,origin_density,"pd.cut(origin_density_measure, bins=[-np.inf, 500, 2000, 5000, 15000, np.inf], labels=[5, 4, 3, 2, 1]).astype(int)",
,dest_density,"pd.cut(dest_density_measure, bins=[-np.inf, 500, 2000, 5000, 15000, np.inf], labels=[5, 4, 3, 2, 1]).astype(int)",
,origin_zone_taxi_wait_time_mean,"origin_density.map({k: v for k, v in Taxi_waitTime_mean.items()})",
,origin_zone_taxi_wait_time_sd,"origin_density.map({k: v for k, v in Taxi_waitTime_sd.items()})",
,dest_zone_taxi_wait_time_mean,"dest_density.map({k: v for k, v in Taxi_waitTime_mean.items()})",
,dest_zone_taxi_wait_time_sd,"dest_density.map({k: v for k, v in Taxi_waitTime_sd.items()})",
# ,, Note that the mean and standard deviation are not the values for the distribution itself, but of the underlying normal distribution it is derived from
,origTaxiWaitTime,"rng.lognormal_for_df(df, mu=origin_zone_taxi_wait_time_mean, sigma=origin_zone_taxi_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,destTaxiWaitTime,"rng.lognormal_for_df(df, mu=dest_zone_taxi_wait_time_mean, sigma=dest_zone_taxi_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,origin_zone_singleTNC_wait_time_mean,"origin_density.map({k: v for k, v in TNC_single_waitTime_mean.items()})",
,origin_zone_singleTNC_wait_time_sd,"origin_density.map({k: v for k, v in TNC_single_waitTime_sd.items()})",
,dest_zone_singleTNC_wait_time_mean,"dest_density.map({k: v for k, v in TNC_single_waitTime_mean.items()})",
,dest_zone_singleTNC_wait_time_sd,"dest_density.map({k: v for k, v in TNC_single_waitTime_sd.items()})",
,origSingleTNCWaitTime,"rng.lognormal_for_df(df, mu=origin_zone_singleTNC_wait_time_mean, sigma=origin_zone_singleTNC_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,destSingleTNCWaitTime,"rng.lognormal_for_df(df, mu=dest_zone_singleTNC_wait_time_mean, sigma=dest_zone_singleTNC_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,origin_zone_sharedTNC_wait_time_mean,"origin_density.map({k: v for k, v in TNC_shared_waitTime_mean.items()})",
,origin_zone_sharedTNC_wait_time_sd,"origin_density.map({k: v for k, v in TNC_shared_waitTime_sd.items()})",
,dest_zone_sharedTNC_wait_time_mean,"dest_density.map({k: v for k, v in TNC_shared_waitTime_mean.items()})",
,dest_zone_sharedTNC_wait_time_sd,"dest_density.map({k: v for k, v in TNC_shared_waitTime_sd.items()})",
,origSharedTNCWaitTime,"rng.lognormal_for_df(df, mu=origin_zone_sharedTNC_wait_time_mean, sigma=origin_zone_sharedTNC_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,destSharedTNCWaitTime,"rng.lognormal_for_df(df, mu=dest_zone_sharedTNC_wait_time_mean, sigma=dest_zone_sharedTNC_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,totalWaitTaxi,origTaxiWaitTime + destTaxiWaitTime,
,totalWaitSingleTNC,origSingleTNCWaitTime + destSingleTNCWaitTime,
,totalWaitSharedTNC,origSharedTNCWaitTime + destSharedTNCWaitTime,
#,,,
,_free_parking_available,(df.tour_type == 'work') & df.free_parking_at_work if _DF_IS_TOUR else False,
,_dest_hourly_peak_parking_cost,"reindex(land_use.PRKCST, df[dest_col_name])",
,_dest_hourly_offpeak_parking_cost,"reindex(land_use.OPRKCST, df[dest_col_name])",
,_hourly_peak_parking_cost,"np.where(_free_parking_available, 0, _dest_hourly_peak_parking_cost)",
,_hourly_offpeak_parking_cost,"np.where(_free_parking_available, 0, _dest_hourly_offpeak_parking_cost)",
,daily_parking_cost,"np.where(is_mandatory, _hourly_peak_parking_cost * df.duration, _hourly_offpeak_parking_cost * df.duration)",
#,,,
,distance,od_skims['DIST'],
,distance_walk_od,od_skims['DIST'],
,distance_bike_od,od_skims['DISTBIKE'],
#,,,
,sov_available,(odt_skims['SOV_TIME']>0) & (dot_skims['SOV_TIME']>0),
,sovtoll_available,(odt_skims['SOVTOLL_VTOLL']>0) | (dot_skims['SOVTOLL_VTOLL']>0),
,hov2_available,(odt_skims['HOV2_TIME'] + dot_skims['HOV2_TIME'])>0,
,hov2toll_available,(odt_skims['HOV2TOLL_VTOLL'] + dot_skims['HOV2TOLL_VTOLL'])>0,
,hov3_available,(odt_skims['HOV3_TIME']>0) & (dot_skims['HOV3_TIME']>0),
,hov3toll_available,(odt_skims['HOV3TOLL_VTOLL'] + dot_skims['HOV3TOLL_VTOLL'])>0,
,,,
#,walkAvailable,"np.where(df.nm_walkTime_in<maximumWalkTime,1,0) * np.where(df.nm_walkTime_out<maximumWalkTime,1,0)",
#,walkTransit_Available,"np.where(df.walkSetLogSum <= -999 , 0, 1)",
#,PNRTransit_Available,"np.where(df.pnrSetLogSum<= -999 , 0, 1)",
#,KNRTransit_Available,"np.where(df.knrSetLogSum<= -999 , 0, 1)",
#,SCHBUSAvailable,"np.where(df.age > 5 , 1, 0)",
,,,
"Value of time threshold, low ($/hour)",votThresholdLow,%valueOfTime.threshold.low%,
"Value of time threshold, medium ($/hour)",votThresholdMed,%valueOfTime.threshold.med%,
"Value of time, drive alone and non-shared ride modes",vot,coef_ivt/c_cost_out * 0.6,
"Value of time, shared 2",votS2,vot/costFactorS2,
"Value of time, shared 3+",votS3,vot/costFactorS3,
Value of time bin,votBin,"np.where(vot<votThresholdLow,1,np.where(vot<votThresholdMed,2,3))",
"Value of time bin, shared 2 tours",votBinS2,"np.where(votS2<votThresholdLow,1,np.where(votS2<votThresholdMed,2,3))",
"Value of time bin, shared 3+ tours",votBinS3,"np.where(votS3<votThresholdLow,1,np.where(votS3<votThresholdMed,2,3))",
#,,,
"Outbound skim index, vot bin * 10 + outPeriod",outSkim,votBin * 10 + outPeriod + ownsTransponder*30,
"Outbound skim index, vot bin * 10 + inPeriod",inSkim,votBin * 10 + inPeriod + ownsTransponder*30,
"Outbound skim index, shared 2 vot bin * 10 + outPeriod",outSkim2,votBinS2 * 10 + outPeriod,
"Outbound skim index, shared 2 vot bin * 10 + inPeriod",inSkim2,votBinS2 * 10 + inPeriod,
"Outbound skim index, shared 3+ vot bin * 10 + outPeriod",outSkim3,votBinS3 * 10 + outPeriod,
"Outbound skim index, shared 3+ vot bin * 10 + inPeriod",inSkim3,votBinS3 * 10 + inPeriod,
#,,,
#,outPeriod,"np.where(df.timeOutBound<=upperEA,1,0)",
#,outPeriod,"np.where(df.timeOutBound>upperEA,1,0)*np.where(df.timeOutBound<=upperAM,2,0)",
#,outPeriod,"np.where(df.timeOutBound>upperAM,1,0)*np.where(df.timeOutBound<=upperMD,3,0)",
#,outPeriod,"np.where(df.timeOutBound>upperMD,1,0)*np.where(df.timeOutBound<=upperPM,4,0)",
#,outPeriod,"np.where(df.timeOutBound>upperPM,5,0)",
#,inPeriod,"np.where(df.timeInBound<=upperEA,1,0)",
#,inPeriod,"np.where(df.timeInBound>upperEA,1,0)*np.where(df.timeInBound<=upperAM,2,0)",
#,inPeriod,"np.where(df.timeInBound>upperAM,1,0)*np.where(df.timeInBound<=upperMD,3,0)",
#,inPeriod,"np.where(df.timeInBound>upperMD,1,0)*np.where(df.timeInBound<=upperPM,4,0)",
#,inPeriod,"np.where(df.timeInBound>upperPM,5,0)",
#,,,
,vot_da,coef_ivt / coef_cost * 0.6,
,vot_s2,vot_da * cost_share_s2,
,vot_s3,vot_da * cost_share_s3,
,_vot_bin_da,"np.where(vot_da < vot_threshold_low, 1, np.where(vot_da < vot_threshold_med, 2, 3))",
,_vot_bin_s2,"np.where(vot_s2 < vot_threshold_low, 1, np.where(vot_s2 < vot_threshold_med, 2, 3))",
,_vot_bin_s3,"np.where(vot_s3 < vot_threshold_low, 1, np.where(vot_s3 < vot_threshold_med, 2, 3))",
vot-indexed skims,da_dist_skims_inb,(((odt_skims['SOV_NT_L_DIST'] )* (_vot_bin_da == 1)) + ((odt_skims['SOV_NT_M_DIST']) * (_vot_bin_da == 2)) + ((odt_skims['SOV_NT_H_DIST']) * (_vot_bin_da == 3))),
,da_dist_skims_out,(((dot_skims['SOV_NT_L_DIST'])* (_vot_bin_da == 1)) + ((dot_skims['SOV_NT_M_DIST']) * (_vot_bin_da == 2)) + ((dot_skims['SOV_NT_H_DIST']) * (_vot_bin_da == 3))),
,da_cost_skims_inb,(((odt_skims['SOV_NT_L_TOLLCOST']) * (_vot_bin_da == 1)) + ((odt_skims['SOV_NT_M_TOLLCOST']) * (_vot_bin_da == 2)) + ((odt_skims['SOV_NT_H_TOLLCOST']) * (_vot_bin_da == 3))),
,da_cost_skims_out,(((dot_skims['SOV_NT_L_TOLLCOST']) * (_vot_bin_da == 1)) + ((dot_skims['SOV_NT_M_TOLLCOST']) * (_vot_bin_da == 2)) + ((dot_skims['SOV_NT_H_TOLLCOST']) * (_vot_bin_da == 3))),
,da_time_skims_inb,(((odt_skims['SOV_NT_L_TOLLCOST']) * (_vot_bin_da == 1)) + ((odt_skims['SOV_NT_M_TOLLCOST']) * (_vot_bin_da == 2)) + ((odt_skims['SOV_NT_H_TOLLCOST']) * (_vot_bin_da == 3))),
,da_time_skims_out,(((dot_skims['SOV_NT_L_TOLLCOST']) * (_vot_bin_da == 1)) + ((dot_skims['SOV_NT_M_TOLLCOST']) * (_vot_bin_da == 2)) + ((dot_skims['SOV_NT_H_TOLLCOST']) * (_vot_bin_da == 3))),
,da_rel_skims_inb,(((odt_skims['SOV_NT_L_REL']) * (_vot_bin_da == 1)) + ((odt_skims['SOV_NT_M_REL']) * (_vot_bin_da == 2)) + ((odt_skims['SOV_NT_H_REL']) * (_vot_bin_da == 3))),
,da_rel_skims_out,(((dot_skims['SOV_NT_L_REL']) * (_vot_bin_da == 1)) + ((dot_skims['SOV_NT_M_REL']) * (_vot_bin_da == 2)) + ((dot_skims['SOV_NT_H_REL']) * (_vot_bin_da == 3))),
,s2_dist_skims_inb,(((odt_skims['HOV2_L_DIST']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV2_M_DIST']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV2_H_DIST']) * (_vot_bin_s2 == 3))),
,s2_dist_skims_out,(((dot_skims['HOV2_L_DIST']) * (_vot_bin_s2 == 1)) + ((dot_skims['HOV2_M_DIST']) * (_vot_bin_s2 == 2)) + ((dot_skims['HOV2_H_DIST']) * (_vot_bin_s2 == 3))),
,s2_cost_skims_inb,(((odt_skims['HOV2_L_TOLLCOST']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV2_M_TOLLCOST']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV2_H_TOLLCOST']) * (_vot_bin_s2 == 3))),
,s2_cost_skims_out,(((dot_skims['HOV2_L_TOLLCOST']) * (_vot_bin_s2 == 1)) + ((dot_skims['HOV2_M_TOLLCOST']) * (_vot_bin_s2 == 2)) + ((dot_skims['HOV2_H_TOLLCOST']) * (_vot_bin_s2 == 3))),
,s2_time_skims_inb,(((odt_skims['HOV2_L_TIME']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV2_M_TIME']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV2_H_TIME']) * (_vot_bin_s2 == 3))),
,s2_time_skims_out,(((dot_skims['HOV2_L_TIME']) * (_vot_bin_s2 == 1)) + ((dot_skims['HOV2_M_TIME']) * (_vot_bin_s2 == 2)) + ((dot_skims['HOV2_H_TIME']) * (_vot_bin_s2 == 3))),
,s2_rel_skims_inb,(((odt_skims['s2_NT_L_REL']) * (_vot_bin_da == 1)) + ((odt_skims['s2_NT_M_REL']) * (_vot_bin_da == 2)) + ((odt_skims['s2_NT_H_REL']) * (_vot_bin_da == 3))),
,s2_rel_skims_out,(((dot_skims['s2_NT_L_REL']) * (_vot_bin_da == 1)) + ((dot_skims['s2_NT_M_REL']) * (_vot_bin_da == 2)) + ((dot_skims['s2_NT_H_REL']) * (_vot_bin_da == 3))),
,s3_dist_skims_inb,(((odt_skims['HOV3_L_DIST']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV3_M_DIST']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV3_H_DIST']) * (_vot_bin_s2 == 3))),
,s3_dist_skims_out,(((dot_skims['HOV3_L_DIST']) * (_vot_bin_s2 == 1)) + (( dot_skims['HOV3_M_DIST']) * (_vot_bin_s2 == 2)) + ((dot_skims['HOV3_H_DIST']) * (_vot_bin_s2 == 3))),
,s3_cost_skims_inb,(((odt_skims['HOV3_L_TOLLCOST']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV3_M_TOLLCOST']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV3_H_TOLLCOST']) * (_vot_bin_s2 == 3))),
,s3_cost_skims_out,(((dot_skims['HOV3_L_TOLLCOST']) * (_vot_bin_s2 == 1)) + ((dot_skims['HOV3_M_TOLLCOST']) * (_vot_bin_s2 == 2)) + ((dot_skims['HOV3_H_TOLLCOST']) * (_vot_bin_s2 == 3))),
,s3_time_skims_inb,(((odt_skims['HOV3_L_TIME']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV3_M_TIME']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV3_H_TIME']) * (_vot_bin_s2 == 3))),
,s3_time_skims_out,(((dot_skims['HOV3_L_TIME']) * (_vot_bin_s2 == 1)) + ((dot_skims['HOV3_M_TIME']) * (_vot_bin_s2 == 2)) + ((dot_skims['HOV3_H_TIME']) * (_vot_bin_s2 == 3))),
,s3_rel_skims_inb,(((odt_skims['s3_NT_L_REL']) * (_vot_bin_da == 1)) + ((odt_skims['s3_NT_M_REL']) * (_vot_bin_da == 2)) + ((odt_skims['s3_NT_H_REL']) * (_vot_bin_da == 3))),
,s3_rel_skims_out,(((dot_skims['s3_NT_L_REL']) * (_vot_bin_da == 1)) + ((dot_skims['s3_NT_M_REL']) * (_vot_bin_da == 2)) + ((dot_skims['s3_NT_H_REL']) * (_vot_bin_da == 3))),
,walk_time_skims_inb,od_skims['walkTime'],
,walk_time_skims_out,do_skims['walkTime'],
#,,,
,walk_available,((walk_time < max_walk_time) & (walk_time > 0)),
#,,,
First wait time coefficient,c_fwt,coef_ivt * 1.5,
Transfer wait time coefficient,c_xwt,coef_ivt * 1.5,
Walk access time coefficient,c_wacc,coef_ivt*1.88*0.8333,
Walk egress time coefficient,c_wegr,coef_ivt*1.88*0.8333,
Walk auxilliary time coefficient,c_waux,coef_ivt*1.88*0.8333,
Drive access time coefficient,c_dtim,coef_ivt*1.88,
Transfer penalty - non-PNR modes,c_xfers,coef_ivt*5,
Transfer penalty - PNR,c_xfers_pnr,coef_ivt*15,
Bike mode time coefficient,c_bikeTime,coef_ivt * 3.075,
,c_rel_out,coef_ivt*14,
,c_rel_inb,coef_ivt*12,
DistanceToCoast,DistancetoCoast,milestocoast,
#,,,
Household autos,autos,df.autos,
Number of adults (age 18+) in household,adults,df.adults,
Household size (number of persons),hhSize,df.hhSize,
Person age,age,df.age,
Person is female,female,df.female,
Household income (in dollars),income,df.incomeInDollars,
Female in party,femaleInParty,df.femaleInParty,
Male in party,maleInParty,df.maleInParty,
"Result of transponder ownership model (1=owns, 0=not)",ownsTransponder,df.transponderOwnership,
"Cost parameter, outbound",c_cost_out,coef_cost,
"Cost parameter, inbound",c_cost_inb,coef_cost,
Use AV coefficients for tour,useAV,df.useOwnedAV,
Auto IVT Factor,autoIVTFactor,"np.where(useAV==0,1.0,autoIVTFactorAV)",
Auto Parking Cost Factor,autoParkingCostFactor,"np.where(useAV==0,1.0,autoParkingCostFactorAV)",
Auto CPM Factor,autoCPMFactor,"np.where(useAV==0,1.0,autoCostPerMileFactorAV)",
Auto Terminal Time Factor,autoTermTimeFactor,"np.where(useAV==0,1.0,autoTerminalTimeFactorAV)",
MinimumAgeDriveAlone,minimumAgeDA,"np.where(useAV==0,16,minAgeDriveAloneAV)",
totalWaitTaxi,totalWaitTaxi,df.origTaxiWaitTime+df.destTaxiWaitTime,
totalWaitSingleTNC,totalWaitSingleTNC,df.origSingleTNCWaitTime+df.destSingleTNCWaitTime,
totalWaitSharedTNC,totalWaitSharedTNC,df.origSharedTNCWaitTime+df.destSharedTNCWaitTime,
#,,,
Zero auto households,zeroAutoHH,"np.where(autos==0,1,0)",
Auto deficient household (more adults than autos),autoDeficientHH,"np.where(autos<adults,1,0) * (np.where(zeroAutoHH,0,1))",
Auto sufficient household (enough autos for each adult),autoSufficientHH,"np.where(autos>=adults,1,0) * (np.where(zeroAutoHH,0,1))",
Time of day for outbound trip,timeOutbound,df.timeOutbound,
Time of day for inbound trip,timeInbound,df.timeInbound,
Joint tour,jointTour,df.tourCategoryJoint,
Number of participants in joint tour,numberOfParticipantsInJointTour,df.numberOfParticipantsInJointTour * jointTour,
Individual tour,indivTour,1 * (jointTour==0),
Origin MGRA Dwelling Unit Density,oMGRADUDen,df.oDUDen,
Origin MGRA Employment Density,oMGRAEmpDen,df.oEmpDen,
Origin MGRA Total Intersections,oMGRATotInt,df.oTotInt,
Destination MGRA Dwelling Unit Density,dMGRADUDen,df.dDUDen,
Destination MGRA Employment Density,dMGRAEmpDen,df.dEmpDen,
Destination MGRA Total Intersections,dMGRATotInt,df.dTotInt,
Origin MGRA Mix,oMGRAMix,"(oMGRADUDen*oMGRAEmpDen)/(oMGRADUDen+oMGRAEmpDen) *np.where(oMGRADUDen+oMGRAEmpDen > 0,1,0)",
Destination MGRA Mix,dMGRAMix,"(dMGRADUDen*dMGRAEmpDen)/(dMGRADUDen+dMGRAEmpDen)*np.where(dMGRADUDen+dMGRAEmpDen > 0,1,0)",
Origin MGRA Dwelling Unit Density Normalized by Average in Bike Estimation Sample,oMGRADUDenNorm_bike,oMGRADUDen/6.77,
Origin MGRA Employment Density Normalized by Average in Bike Estimation Sample,oMGRAEmpDenNorm_bike,oMGRAEmpDen/6.47,
Origin MGRA Dwelling Unit Density Normalized by Average in Walk Estimation Sample,oMGRADUDenNorm_walk,oMGRADUDen/7.18,
Origin MGRA Total Intersections Normalized by Average in Walk Estimation Sample,oMGRATotIntNorm_walk,oMGRATotInt/56.19,
Destination MGRA Employment Density Normalized by Average in Walk Estimation Sample,dMGRAEmpDenNorm_walk,dMGRAEmpDen/13.16,
Normalized Landuse Variable Sum [Origin Employment + DU],LUVarsNormalized_bike,oMGRADUDenNorm_bike + oMGRAEmpDenNorm_bike,
Normalized Landuse Variable Sum [Origin Intersection + DU],LUVarsNormalized_walk,oMGRADUDenNorm_walk + oMGRATotIntNorm_walk,
"Tour duration, in hours",tourDuration,(timeInbound - timeOutbound)/2,
persontype,personType,"df.personType*np.where(indivTour,1,0)",
Result of employer parking provision and reimbursement model,freeParkingEligibility,"df.freeParkingEligibility*np.where(indivTour,1,0)",
person has free on-site parking at workplace,freeOnsite,"(freeParkingEligibility == 1)*np.where(indivTour,1,0)",
new reimbursement amount,reimburseProportion,"df.reimburseProportion*np.where(indivTour,1,0)",
new daily parking cost with reimbursement,parkingCostDayDollars,df.dailyParkingCost,
new hourly parking cost with reimbursement,parkingCostHourDollars,df.hourlyParkingCost,
new monthly parking cost with reimbursement,parkingCostMonthDollars,df.monthlyParkingCost,
Parking area,parkingConstrainedArea,df.parkingArea==1,
daily cost converted to cents,parkingCostDay,parkingCostDayDollars*100,
hourly cost converted to cents,parkingCostHour,parkingCostHourDollars*100,
monthly cost converted to cents,parkingCostMonth,parkingCostMonthDollars*100,
Tour parking cost for full-time workers and university students,parkingCostBeforeReimbx,"min(parkingCostMonth, parkingCostDay)*(indivTour*((personType == 1) + (personType == 3)))",
Tour parking cost for full-time workers and university students,parkingCostBeforeReimb,"min(parkingCostBeforeReimbx, parkingCostHour * tourDuration) * (indivTour*((personType == 1) + (personType == 3)))",
Tour parking cost for other person types,parkingCostBeforeReimb,"min(parkingCostDay, parkingCostHour * tourDuration)*(jointTour+indivTour*(1-(personType == 1) - (personType == 3)))",
Reimbursement applies to this tour purpose,reimbursePurpose,1,
Effective parking cost for free parkers,parkingCost,"0 * np.where(indivTour*reimbursePurpose * freeOnsite,1,0)",
Effective parking cost for reimbursed parkers,parkingCost,"max( (1-reimburseProportion) * parkingCostBeforeReimb, 0) * np.where((indivTour*reimbursePurpose * (1 - freeOnsite)),1,0)",
Effective parking cost if no reimbursement applied to tour purpose,parkingCost,"parkingCostBeforeReimb * np.where((jointTour+indivTour*(1-reimbursePurpose)),1,0)",
Origin Terminal Time,oTermTime,df.PTazTerminalTime,
Destination Terminal Time,dTermTime,df.ATazTerminalTime,
#,,,
"Bike - logsum (inbound, male)",bikeLogsumIM,df.inboundMaleBikeLogsum,
"Bike - logsum (outbound, male)",bikeLogsumOM,df.outboundMaleBikeLogsum,
"Bike - logsum (inbound, female)",bikeLogsumIF,df.inboundFemaleBikeLogsum,
"Bike - logsum (outbound, female)",bikeLogsumOF,df.outboundFemaleBikeLogsum,
Bike - Mode available male (multiplication ensures counting both directions),bikeAvailableM,"np.where(bikeLogsumIM>-300,1,0) * np.where(bikeLogsumOM>-300,1,0) * maleinParty",
Bike - Mode available female (multiplication ensures counting both directions),bikeAvailableF,"np.where(bikeLogsumIF>-300,1,0) * np.where(bikeLogsumOF>-300,1,0) * femaleInParty",
Bike - Mode available (account correctly for male/female existence,bikeAvailable,((1-maleInParty) + bikeAvailableM)*((1-femaleInParty) + bikeAvailableF),
Bike - joint inbound logsum minimum,jointMinBikeLSI,"min(bikeLogsumIM,bikeLogsumIF) * jointTour",
Bike - joint outbound logsum minimum,jointMinBikeLSO,"min(bikeLogsumOM,bikeLogsumOF) * jointTour",
Bike - logsum inbound,bikeLSI,"np.where((maleInParty+femaleInParty)>1,jointMinBikeLSI,maleInParty*bikeLogsumIM+femaleInParty*bikeLogsumIF)",
Bike - logsum outbound,bikeLSO,"np.where((maleInParty+femaleInParty)>1,jointMinBikeLSO,maleInParty*bikeLogsumOM+femaleInParty*bikeLogsumOF)",
