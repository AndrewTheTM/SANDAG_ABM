Description,Target,Expression,
,is_joint,(df.number_of_participants > 1),
,is_indiv,(df.number_of_participants == 1),
#,,,
#,,,
#,,estimation_larch,
#,ivot,1.0 / df.value_of_time,
#,,,
,demographic_segment,df.income_segment.map(TVPB_demographic_segments_by_income_segment),
,dest_density_index,"reindex(land_use.density_index, df[dest_col_name])",
#,,,
#,,,
# #,,develop,
# ,c_cost,(0.60 * c_ivt) / df.value_of_time,
# #,,,
# # TVPB,,,
# #,,,
# ,demographic_segment,df.income_segment.map(TVPB_demographic_segments_by_income_segment),
# ,c_ivt_for_segment,"np.where(demographic_segment==C_LOW_INCOME_SEGMENT_ID,c_ivt_low_income, c_ivt_high_income)",
# ,c_cost_for_segment,"np.where(demographic_segment==C_LOW_INCOME_SEGMENT_ID,c_cost_low_income, c_cost_high_income)",
#,,,
# cost coef,,,
,income_exponent,"np.where(df.tour_type == 'work', 0.6, 0.5)",
,c_cost,"(coef_income) /(df.income.clip(0,1000).pow(income_exponent))",
# ivt coef,,,
#,time_factor,"np.where(df.tour_type=='work', df.time_factor_work, df.time_factor_nonwork)",
time_factor placeholder,time_factor,1,
,c_ivt,coef_ivt * time_factor,
#,,,
coef_cost placeholder,coef_cost,-.001,
,vot_da,coef_ivt / coef_cost * 0.6,
,vot_s2,vot_da / cost_share_s2,
,vot_s3,vot_da / cost_share_s3,
,vot_da,coef_ivt / coef_cost * 0.6,
,vot_s2,vot_da / cost_share_s2,
,vot_s3,vot_da / cost_share_s3,
,_vot_bin_da,"np.where(vot_da < vot_threshold_low, 1, np.where(vot_da < vot_threshold_med, 2, 3))",
,_vot_bin_s2,"np.where(vot_s2 < vot_threshold_low, 1, np.where(vot_s2 < vot_threshold_med, 2, 3))",
,_vot_bin_s3,"np.where(vot_s3 < vot_threshold_low, 1, np.where(vot_s3 < vot_threshold_med, 2, 3))",
#"Result of transponder ownership model (1=owns, 0=not)",ownsTransponder,df.transponderOwnership,
"Placeholder - Transponder ownership model not yet implemented",ownsTransponder,1,
#vot-indexed skims,,,
DA skim based on Transponder ownership,da_dist_skims,"(np.where(ownsTransponder==1, odt_skims['SOV_TR_L_DIST'], odt_skims['SOV_NT_L_DIST']) * (_vot_bin_da == 1)) + (np.where(ownsTransponder==1, odt_skims['SOV_TR_M_DIST'], odt_skims['SOV_NT_M_DIST']) * (_vot_bin_da == 2)) + (np.where(ownsTransponder==1, odt_skims['SOV_TR_H_DIST'], odt_skims['SOV_NT_H_DIST']) * (_vot_bin_da == 3))",
,da_cost_skims,"(np.where(ownsTransponder==1, odt_skims['SOV_TR_L_TOLLCOST'], odt_skims['SOV_NT_L_TOLLCOST']) * (_vot_bin_da == 1)) + (np.where(ownsTransponder==1, odt_skims['SOV_TR_M_TOLLCOST'], odt_skims['SOV_NT_M_TOLLCOST']) * (_vot_bin_da == 2)) + (np.where(ownsTransponder==1, odt_skims['SOV_TR_H_TOLLCOST'], odt_skims['SOV_NT_H_TOLLCOST']) * (_vot_bin_da == 3))",
,da_time_skims,"(np.where(ownsTransponder==1, odt_skims['SOV_TR_L_TIME'], odt_skims['SOV_NT_L_TIME']) * (_vot_bin_da == 1)) + (np.where(ownsTransponder==1, odt_skims['SOV_TR_M_TIME'], odt_skims['SOV_NT_M_TIME']) * (_vot_bin_da == 2)) + (np.where(ownsTransponder==1, odt_skims['SOV_TR_H_TIME'], odt_skims['SOV_NT_H_TIME']) * (_vot_bin_da == 3))",
,da_rel_skims,(((odt_skims['SOV_NT_L_REL']) * (_vot_bin_da == 1)) + ((odt_skims['SOV_NT_M_REL']) * (_vot_bin_da == 2)) + ((odt_skims['SOV_NT_H_REL']) * (_vot_bin_da == 3))),
,s2_dist_skims,(((odt_skims['HOV2_L_DIST']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV2_M_DIST']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV2_H_DIST']) * (_vot_bin_s2 == 3))),
,s2_cost_skims,(((odt_skims['HOV2_L_TOLLCOST']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV2_M_TOLLCOST']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV2_H_TOLLCOST']) * (_vot_bin_s2 == 3))),
,s2_time_skims,(((odt_skims['HOV2_L_TIME']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV2_M_TIME']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV2_H_TIME']) * (_vot_bin_s2 == 3))),
,s2_rel_skims,(((odt_skims['HOV2_L_REL']) * (_vot_bin_da == 1)) + ((odt_skims['HOV2_M_REL']) * (_vot_bin_da == 2)) + ((odt_skims['HOV2_H_REL']) * (_vot_bin_da == 3))),
,s3_dist_skims,(((odt_skims['HOV3_L_DIST']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV3_M_DIST']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV3_H_DIST']) * (_vot_bin_s2 == 3))),
,s3_cost_skims,(((odt_skims['HOV3_L_TOLLCOST']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV3_M_TOLLCOST']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV3_H_TOLLCOST']) * (_vot_bin_s2 == 3))),
,s3_time_skims,(((odt_skims['HOV3_L_TIME']) * (_vot_bin_s2 == 1)) + ((odt_skims['HOV3_M_TIME']) * (_vot_bin_s2 == 2)) + ((odt_skims['HOV3_H_TIME']) * (_vot_bin_s2 == 3))),
,s3_rel_skims,(((odt_skims['HOV3_L_REL']) * (_vot_bin_da == 1)) + ((odt_skims['HOV3_M_REL']) * (_vot_bin_da == 2)) + ((odt_skims['HOV3_H_REL']) * (_vot_bin_da == 3))),
,walk_time_skims,od_skims['walkTime'],
#,,,
,inbound,~df.outbound,
,first_trip,df.trip_num == 1,
,last_trip,df.trip_num == df.trip_count,
#,,,
# FIXME no transit subzones so all zones short walk to transit,,,
,_walk_transit_origin,True,
,_walk_transit_destination,True,
,walk_transit_available,_walk_transit_origin & _walk_transit_destination,
,drive_transit_available,"np.where(df.outbound, _walk_transit_destination, _walk_transit_origin) & (df.auto_ownership > 0)",
# RIDEHAIL,,,
household_density calculated in annotate_landuse in acres and is converted to sq miles here,origin_density_measure,"reindex(land_use.household_density, df[orig_col_name]) / 640",
employment_density calculated in annotate_landuse in acres and is converted to sq miles here,dest_density_measure,"reindex(land_use.household_density, df[dest_col_name]) / 640",
,origin_density,"pd.cut(origin_density_measure, bins=[-np.inf, 500, 2000, 5000, 15000, np.inf], labels=[5, 4, 3, 2, 1]).astype(int)",
,dest_density,"pd.cut(dest_density_measure, bins=[-np.inf, 500, 2000, 5000, 15000, np.inf], labels=[5, 4, 3, 2, 1]).astype(int)",
Origin MGRA Dwelling Unit Density,oMGRADUDen,"reindex(land_use.household_density,df.origin)",
Origin MGRA Employment Density,oMGRAEmpDen,"reindex(land_use.employment_density,df.origin)",
Origin MGRA Total Intersections,oMGRATotInt,"reindex(land_use.totint,df.origin)",
Destination MGRA Dwelling Unit Density,dMGRADUDen,"reindex(land_use.household_density,df.destination)",
Destination MGRA Employment Density,dMGRAEmpDen,"reindex(land_use.employment_density,df.destination)",
Destination MGRA Total Intersections,dMGRATotInt,"reindex(land_use.totint,df.destination)",
Origin MGRA Mix,oMGRAMix,"np.where(oMGRADUDen+oMGRAEmpDen > 0,(oMGRADUDen*oMGRAEmpDen)/(oMGRADUDen+oMGRAEmpDen),0)",
Destination MGRA Mix,dMGRAMix,"np.where(dMGRADUDen+dMGRAEmpDen > 0,(dMGRADUDen*dMGRAEmpDen)/(dMGRADUDen+dMGRAEmpDen),0)",
,origin_zone_taxi_wait_time_mean,"origin_density.map({k: v for k, v in Taxi_waitTime_mean.items()})",
,origin_zone_taxi_wait_time_sd,"origin_density.map({k: v for k, v in Taxi_waitTime_sd.items()})",
,dest_zone_taxi_wait_time_mean,"dest_density.map({k: v for k, v in Taxi_waitTime_mean.items()})",
,dest_zone_taxi_wait_time_sd,"dest_density.map({k: v for k, v in Taxi_waitTime_sd.items()})",
# ,, Note that the mean and standard deviation are not the values for the distribution itself,
,origTaxiWaitTime,"rng.lognormal_for_df(df, mu=origin_zone_taxi_wait_time_mean, sigma=origin_zone_taxi_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,destTaxiWaitTime,"rng.lognormal_for_df(df, mu=dest_zone_taxi_wait_time_mean, sigma=dest_zone_taxi_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,origin_zone_singleTNC_wait_time_mean,"origin_density.map({k: v for k, v in TNC_single_waitTime_mean.items()})",
,origin_zone_singleTNC_wait_time_sd,"origin_density.map({k: v for k, v in TNC_single_waitTime_sd.items()})",
,dest_zone_singleTNC_wait_time_mean,"dest_density.map({k: v for k, v in TNC_single_waitTime_mean.items()})",
,dest_zone_singleTNC_wait_time_sd,"dest_density.map({k: v for k, v in TNC_single_waitTime_sd.items()})",
,origSingleTNCWaitTime,"rng.lognormal_for_df(df, mu=origin_zone_singleTNC_wait_time_mean, sigma=origin_zone_singleTNC_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,destSingleTNCWaitTime,"rng.lognormal_for_df(df, mu=dest_zone_singleTNC_wait_time_mean, sigma=dest_zone_singleTNC_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,origin_zone_sharedTNC_wait_time_mean,"origin_density.map({k: v for k, v in TNC_shared_waitTime_mean.items()})",
,origin_zone_sharedTNC_wait_time_sd,"origin_density.map({k: v for k, v in TNC_shared_waitTime_sd.items()})",
# wrong? producing bad probs error,dest_zone_sharedTNC_wait_time_mean,"np.maximum((200+(-133 * da_dist_skims)),0) * time_factor",
,dest_zone_sharedTNC_wait_time_mean,"dest_density.map({k: v for k, v in TNC_shared_waitTime_mean.items()})",
,dest_zone_sharedTNC_wait_time_sd,"dest_density.map({k: v for k, v in TNC_shared_waitTime_sd.items()})",
,origSharedTNCWaitTime,"rng.lognormal_for_df(df, mu=origin_zone_sharedTNC_wait_time_mean, sigma=origin_zone_sharedTNC_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,destSharedTNCWaitTime,"rng.lognormal_for_df(df, mu=dest_zone_sharedTNC_wait_time_mean, sigma=dest_zone_sharedTNC_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,totalWaitTaxi,origTaxiWaitTime + destTaxiWaitTime,
,totalWaitSingleTNC,origSingleTNCWaitTime + destSingleTNCWaitTime,
,totalWaitSharedTNC,origSharedTNCWaitTime + destSharedTNCWaitTime,
#,,,
,_free_parking_available,(df.tour_type == 'work') & df.free_parking_at_work,
,_dest_hourly_peak_parking_cost,"reindex(land_use.hparkcost, df[dest_col_name])",
,_dest_hourly_offpeak_parking_cost,"reindex(land_use.hparkcost, df[dest_col_name])",
,_hourly_peak_parking_cost,"np.where(_free_parking_available, 0, _dest_hourly_peak_parking_cost)",
,_hourly_offpeak_parking_cost,"np.where(_free_parking_available, 0, _dest_hourly_offpeak_parking_cost)",
,is_mandatory,(df.tour_category=='mandatory'),
,daily_parking_cost,"np.where(is_mandatory, _hourly_peak_parking_cost * df.duration, _hourly_offpeak_parking_cost * df.duration)",
#,,,
First wait time coefficient,c_fwt,"np.where(df.purpose=='univ', 1.94, 1.5)",
Walk access time coefficient,c_wacc,"np.where(df.purpose=='work', 1.88*0.8333, np.where(df.purpose=='univ', 1.60, np.where(df.purpose=='school', 3.75, np.where(df.purpose=='maint',1.25, np.where(df.purpose=='disc', 1.44, 1.67))))) ",
Walk egress time coefficient,c_wegr,"np.where(df.purpose=='work', 1.5, np.where(df.purpose=='univ', 1.94, np.where(df.purpose=='school', 2.0, np.where(df.purpose=='maint',1.7, np.where(df.purpose=='disc', 1.83, 1.5))))) ",
Walk auxilliary time coefficient,c_waux,"np.where(df.purpose=='work', 1.5, np.where(df.purpose=='univ', 1.94, np.where(df.purpose=='school', 2.0, np.where(df.purpose=='maint',1.7, np.where(df.purpose=='disc', 1.83, 1.5))))) ",
Drive access time coefficient,c_dtim,"np.where(df.purpose=='work', 1.88, np.where(df.purpose=='univ', 1.60, np.where(df.purpose=='school', 0.76, np.where(df.purpose=='maint',1.5, np.where(df.purpose=='disc', 1.5, 2.0))))) ",
Transfer penalty - non-PNR modes,c_xfers,5 * c_ivt,
Transfer penalty - PNR,c_xfers_pnr,15 * c_ivt,
Bike mode time coefficient,c_bikeTime,c_ivt * 3.075,
,c_rel,"np.where((df.purpose=='work')&~(df.outbound), 14, 12)",
#DistanceToCoast,DistancetoCoast,milestocoast,
placeholder for undefined milestocoast,DistanceToCoast,5,
#,,,
Household autos,autos,df.auto_ownership,
Number of adults (age 18+) in household,adults,df.num_adults,
Household size (number of persons),hhSize,df.hhsize,
Person age,age,df.age,
Person is female,female,(df.sex == 2),
Household income (in dollars),income,df.income,
# Female in party,femaleInParty,df.femaleInParty,
# Male in party,maleInParty,df.maleInParty,
# Use AV coefficients for tour,useAV,df.useOwnedAV,
useAV placeholder,useAV,False,
Auto IVT Factor,autoIVTFactor,"np.where(useAV==0,1.0,autoIVTFactorAV)",
Auto Parking Cost Factor,autoParkingCostFactor,"np.where(useAV==0,1.0,autoParkingCostFactorAV)",
Auto CPM Factor,autoCPMFactor,"np.where(useAV==0,1.0,autoCostPerMileFactorAV)",
Auto Terminal Time Factor,autoTermTimeFactor,"np.where(useAV==0,1.0,autoTerminalTimeFactorAV)",
MinimumAgeDriveAlone,minimumAgeDA,"np.where(useAV==0,16,minAgeDriveAloneAV)",
#,,,
Zero auto households,zeroAutoHH,"np.where(autos==0,1,0)",
Auto deficient household (more adults than autos),autoDeficientHH,"np.where(autos<adults,1,0) * (np.where(zeroAutoHH,0,1))",
Auto sufficient household (enough autos for each adult),autoSufficientHH,"np.where(autos>=adults,1,0) * (np.where(zeroAutoHH,0,1))",
Joint tour,jointTour,(df.tour_category == 'joint'),
Number of participants in joint tour,numberOfParticipantsInJointTour,df.number_of_participants * jointTour,
Individual tour,indivTour,1 * (jointTour==0),
# Number of stops - outbound direction,outStops,df.outboundStops,
# Number of stops - return direction,retStops,df.returnStops,
# Total stops on tour,totStops,outStops + retStops,
# First trip of tour,firstTrip,df.firstTrip,
# Last trip of tour,lastTrip,df.lastTrip,
# First leg of multi-stop outbound,firstOfMultipleTrips,firstTrip *outStops,
# Last leg of multi-stop return,lastofMultipleTrips,lastTrip * retStops,
# Flag for setting availability of auto modes for drive-transit access/egress trip segments,autoAllowedForDriveTransit,df.autoModeAllowedForTripSegment,
# Flag for setting availability of walk mode for drive-transit access/egress trip segments,walkAllowedForDriveTransit,df.walkModeAllowedForTripSegment,
Tour mode is drive-alone,tourDA,(df.tour_mode == 'DRIVEALONE').astype(int),
Tour mode is shared-2,tourS2,(df.tour_mode == 'SHARED2').astype(int),
Tour mode is shared-3+,tourS3,(df.tour_mode == 'SHARED3').astype(int),
Tour mode is walk,tourWalk,(df.tour_mode == 'WALK').astype(int),
Tour mode is bike,tourBike,(df.tour_mode == 'BIKE').astype(int),
Tour mode is walk-transit,tourWTran,(df.tour_mode == 'WALK_TRANSIT').astype(int),
Tour mode is PNR-transit,tourPNR,(df.tour_mode == 'PNR_TRANSIT').astype(int),
Tour mode is KNR-transit,tourKNR,(df.tour_mode == 'KNR_TRANSIT').astype(int),
Tour mode is TNR-transit,tourTNR,(df.tour_mode == 'TNC_TRANSIT').astype(int),
Tour mode is MaaS,tourMaaS,"(df.tour_mode.isin(['TAXI', 'TNC_SINGLE', 'TNC_SHARED'])).astype(int)",
# again many are not used but nevertheless defined in the java version,,,
#,,,
#Time of day for outbound trip,timeOutbound,df.timeOutbound,
#Time of day for inbound trip,timeInbound,df.timeInbound,
#"Tour duration, in hours",tourDuration,(timeInbound - timeOutbound)/2,
#new reimbursement amount,reimburseAmount,df.reimburseAmount,
#"new hourly parking cost with reimbursement, dollars",parkingCostDayDollars,df.dailyParkingCostTourDest,
#"new daily parking cost with reimbursement, dollars",parkingCostHourDollars,df.hourlyParkingCostTourDest,
#"new monthly parking cost with reimbursement, dollars",parkingCostMonthDollars,df.monthlyParkingCostTourDest,
#new hourly parking cost with reimbursement,parkingCostDay,parkingCostDayDollars*100,
#new daily parking cost with reimbursement,parkingCostHour,parkingCostHourDollars*100,
#new monthly parking cost with reimbursement,parkingCostMonth,parkingCostMonthDollars*100,
#Prim dest parking cost for full-time workers and university students,parkingCostBeforeReimbx,"min(parkingCostMonth, parkingCostDay) * indivTour*((df.personType == 1) + (df.personType == 3))",
#Prim dest parking cost for full-time workers and university students,parkingCostBeforeReimb,"min(parkingCostBeforeReimbx, parkingCostHour * tourDuration) * indivTour*((df.personType == 1) + (df.personType == 3))",
#Prim dest parking cost for other person types,parkingCostBeforeReimb,"min(parkingCostDay, parkingCostHour * tourDuration) * jointTour+indivTour*(1-(df.personType == 1) - (df.personType == 3))",
#Reimbursement applies to this tour purpose,reimbursePurpose,1,
#Effective parking cost for free parkers,parkingCostPrimDest,"np.where(indivTour*reimbursePurpose * df.freeOnsite.0,1)",
#Effective parking cost for reimbursed parkers,parkingCostPrimDest,"np.maximum( (1-reimburseAmount) * parkingCostBeforeReimb, 0) * indivTour*reimbursePurpose * (1 - df.freeOnsite)",
#Effective parking cost if no reimbursement applied to tour purpose,parkingCostPrimDest,parkingCostBeforeReimb * (jointTour + indivTour*(1-reimbursePurpose)),
#Total trips on tour,totalTrips,totStops+2,
#Indicator for trip origin is tour prim. Destination,tripOrigIsTourDest,df.tripOrigIsTourDest,
#Indicator for trip destination is tour prim. Destination,tripDestIsTourDest,df.tripDestIsTourDest,
#Contribution to trip parking cost from primary destination,parkCostTourDestContrib,parkingCostPrimDest/(totalTrips+2),
#Hourly parking cost at trip origin,parkCostTripOrigDollars,df.hourlyParkingCostTripOrig,
#Hourly parking cost at trip destination,parkCostTripDestDollars,df.hourlyParkingCostTripDest,
#"Hourly parking cost at trip origin, cents",parkCostTripOrig,parkCostTripOrigDollars*100,
#"Hourly parking cost at trip destination, cents",parkCostTripDest,parkCostTripDestDollars*100,
#Contribution to trip parking cost from trip origin,parkCostTripOrigContrib,parkCostTripOrig*(1-firstTrip)*(1-tripOrigIsTourDest),
#Contribution to trip parking cost from trip origin,parkCostTripOrigContrib,parkingCostPrimDest/(totalTrips+2) * tripOrigIsTourDest,
#Contribution to trip parking cost from trip destination,parkCostTripDestContrib,parkCostTripDest * (1-lastTrip)*(1-tripDestIsTourDest),
#Contribution to trip parking cost from trip destination,parkCostTripDestContrib,parkingCostPrimDest/(totalTrips+2) * tripDestIsTourDest,
#Final parking cost,parkingCost,parkCostTourDestContrib + parkCostTripOrigContrib + parkCostTripDestContrib,
Final parking cost placeholder,parkingCost,0,
#,,
# Origin Terminal Time,oTermTime,df.PTazTerminalTime,
# Destination Terminal Time,dTermTime,df.ATazTerminalTime,
#origin terminal time not counted at home,_origin_terminal_time,"np.where(df.outbound & first_trip, 0, reindex(land_use.TERMINAL, df[ORIGIN]))",
#dest terminal time not counted at home,_dest_terminal_time,"np.where(inbound & last_trip, 0, reindex(land_use.TERMINAL, df[DESTINATION]))",
placeholder Origin Terminal Time,oTermTime,0,
placeholder Destination Terminal Time,dTermTime,0,
#,,,
# Bike - logsum (male),bikeLogsumM,df.maleBikeLogsum,
# Bike - logsum (female),bikeLogsumF,df.femaleBikeLogsum,
# Bike - Mode available male,bikeAvailableM,"np.where(bikeLogsumM>-300,1,0) * maleInParty",
# Bike - Mode available female,bikeAvailableF,"np.where(bikeLogsumF>-300,1,0) * femaleInParty",
# Bike - joint min logsum,jointMinBikeLS,"min(bikeLogsumM,bikeLogsumF) * jointTour",
# Bike - logsum,bikeLS,"if(maleInParty+femaleInParty>1,jointMinBikeLS,maleInParty*bikeLogsumM+femaleInParty*bikeLogsumF)",
bike logsum,bikeLS,od_skims['BIKE_LOGSUM'],
#placeholder for bike logsum,bikeLS,0.5,
#,,,
"Cost factor for shared 2 tours, 1/(2^0.8)",costFactorS2,0.57,
"Cost factor for shared 3+ tours, 1/(3.5^0.8)",costFactorS3,0.37,
#,,,
,sov_available,"(autos>0) * (age>=minimumAgeDA) * np.where((tourDA+tourS2+tourS3+tourWalk+tourBike+tourPNR+tourKNR) > 0,0,1)",
,hov2_available,"np.where(tourS2+tourS3+tourWalk+tourBike > 0,0,1)",
,hov3_available,"np.where(tourS3+tourWalk+tourBike > 0,0,1)",
No walk on sov and pnr tours and no long walks,walkAvailable,"np.where(walk_time_skims < max_walk_time,1,0) * np.where(tourWTran+tourKNR+tourTNR+tourWalk+tourS2+tourS3 > 0,0,1)",
#Bike - Mode available (account correctly for male/female existence,bikeAvailable,((1-maleInParty) + bikeAvailableM)*((1-femaleInParty) + bikeAvailableF),
Bike - Mode available placeholder,bikeAvailable,(bikeLS < -500) * tourBike,
#,WLK_available,"np.where(tvpb_logsum_odt['WTW'] <= -500 , 0, 1) * np.where(tourWTran + tourPNR + tourKNR + tourTNR > 0,0,1)",
#,PNR_available,"np.where(tvpb_logsum_odt['PTW'] <= -500 , 0, 1) * tourPNR * (autos>0) * (age>15)",
#,KNR_available,"np.where((tvpb_logsum_odt['KTW'] <= -500) | (tvpb_logsum_odt['NTW'] <= -500), 0, 1) * np.where(tourKNR + tourTNR > 0,0,1)",
,WLK_available,"np.where(tourWTran + tourPNR + tourKNR + tourTNR > 0,0,1)",
,PNR_available,"tourPNR * (autos>0) * (age>15)",
,KNR_available,"np.where(tourKNR + tourTNR > 0,0,1)",
#WLK_available placeholder,WLK_available,1,
#PNR_available placeholder,PNR_available,1,
#KNR_available placeholder,KNR_available,1,
,SCHBUS_available,"(df.tour_type =='school') * np.where(tourDA+tourPNR > 0,0,1)",
#,,,
walktime coef for all but atwork,c_walkTime,"np.where(df.purpose=='work', 2.65, np.where(df.purpose=='univ', 2.77, np.where(df.purpose=='school', 6.80, np.where(df.purpose=='maint', 2.35, np.where(df.purpose=='disc', 2.14, 0)))))",
atwork walktime coef,c_walkTime_cte,"np.where(df.purpose=='subtour', -0.1592596416675, 0)",
