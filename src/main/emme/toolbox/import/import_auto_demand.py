#//////////////////////////////////////////////////////////////////////////////
#////                                                                       ///
#//// Copyright INRO, 2016-2017.                                            ///
#//// Rights to use and modify are granted to the                           ///
#//// San Diego Association of Governments and partner agencies.            ///
#//// This copyright notice must be preserved.                              ///
#////                                                                       ///
#//// import/import_auto_demand.py                                       ///
#////                                                                       ///
#////                                                                       ///
#////                                                                       ///
#////                                                                       ///
#//////////////////////////////////////////////////////////////////////////////
# 
# Imports the auto demand matrices generated from an iteration of the disaggregate 
# demand models (CT-RAMP) and adds the saved disaggregated demand matrices to 
# generate the total auto demand in preparation for the auto assignment.
# 
# Note the matrix name mapping from the OMX file names to the Emme database names.
#
# Inputs:
#    external_zones: set of external zone IDs as a range "1-12"
#    output_dir: output directory to read the OMX files from
#    num_processors: number of processors to use in the matrix calculations 
#    scenario: traffic scenario to use for reference zone system
#
# Files referenced:
#    Note: pp is time period, one of EA, AM, MD, PM, EV, vot is one of low, med, high
#    output/autoInternalExternalTrips_pp_vot.omx
#    output/autoVisitorTrips_pp_vot.omx
#    output/autoCrossBorderTrips_pp_vot.omx
#    output/autoAirportTrips.SAN_pp_vot.omx
#    output/autoAirportTrips.CDX_pp_vot.omx (if they exist)
#    output/autoTrips_pp_vot.omx
#    output/othrTrips_pp.omx (added to high vot)
#    output/TripMatrices.csv
#
# Matrix inputs:
#    pp_SOVGP_EIWORK, pp_SOVGP_EINONWORK, pp_SOVTOLL_EIWORK, pp_SOVTOLL_EINONWORK,
#    pp_HOV2HOV_EIWORK, pp_HOV2HOV_EINONWORK, pp_HOV2TOLL_EIWORK, pp_HOV2TOLL_EINONWORK,
#    pp_HOV3HOV_EIWORK, pp_HOV3HOV_EINONWORK, pp_HOV3TOLL_EIWORK, pp_HOV3TOLL_EINONWORK
#    pp_SOV_EETRIPS, pp_HOV2_EETRIPS, pp_HOV3_EETRIPS
#
# Matrix results:
#    Note: pp is time period, one of EA, AM, MD, PM, EV, v is one of L, M, H
#    pp_SOVGPv, pp_SOVTOLLv, pp_HOV2HOVv, pp_HOV2TOLLv, pp_HOV3HOVv, pp_HOV3TOLLv
#
# Script example:
"""
    import os
    modeller = inro.modeller.Modeller()
    main_directory = os.path.dirname(os.path.dirname(modeller.desktop.project.path))
    output_dir = os.path.join(main_directory, "output")
    external_zones = "1-12"
    num_processors = "MAX-1"
    base_scenario = modeller.scenario
    import_auto_demand = modeller.tool("sandag.import.import_auto_demand")
    import_auto_demand(external_zones, output_dir, num_processors, base_scenario)
"""

TOOLBOX_ORDER = 13


import inro.modeller as _m
import traceback as _traceback
import pandas as _pandas
import os
import numpy

_join = os.path.join

dem_utils = _m.Modeller().module('sandag.utilities.demand')
gen_utils = _m.Modeller().module("sandag.utilities.general")


class ImportMatrices(_m.Tool(), gen_utils.Snapshot):

    external_zones = _m.Attribute(str)
    output_dir = _m.Attribute(unicode)
    num_processors = _m.Attribute(str)
    
    tool_run_msg = ""

    @_m.method(return_type=_m.UnicodeType)
    def tool_run_msg_status(self):
        return self.tool_run_msg

    def __init__(self):
        self.external_zones = "1-12"
        project_dir = os.path.dirname(_m.Modeller().desktop.project.path)
        main_dir = os.path.dirname(project_dir)
        self.main_dir = main_dir
        self.output_dir = os.path.join(main_dir, "output")
        self.num_processors = "MAX-1"
        self.attributes = ["external_zones", "output_dir", "num_processors"]

    def page(self):
        pb = _m.ToolPageBuilder(self)
        pb.title = "Import auto demand and sum matrices"
        pb.description = """ 
<div style="text-align:left">    
    Imports the trip matrices generated by CT-RAMP in OMX format, 
    the commercial vehicle demand in CSV format, 
    and adds the demand from the aggregate models for the final
    trip assignments. <br>
    A total of 90 OMX files are expected, for 5 time periods
    EA, AM, MD, PM and EV, and value-of-time level low, med or high,
    with internal matrices by SOV, HOV2, HOV3+ and toll access type:
    <ul>
        <li>autoInternalExternalTrips_pp_vot.omx</li>
        <li>autoVisitorTrips_pp_vot.omx</li>
        <li>autoCrossBorderTrips_pp_vot.omx</li>
        <li>autoAirportTrips.SAN_pp_vot.omx</li>
        <li>autoAirportTrips.CDX_pp_vot.omx (optional)</li>
        <li>autoTrips_pp_vot.omx</li>
    </ul>
    As well as one CSV file "TripMatrices.csv" for the commercial vehicle trips.
    Adds the aggregate demand from the
    external-external and external-internal demand matrices:
    <ul>
        <li>pp_SOVGP_EETRIPS, pp_HOV2HOV_EETRIPS, pp_HOV3HOV_EETRIPS</li>
        <li>pp_SOVGP_EIWORK, pp_SOVGP_EINONWORK, pp_SOVTOLL_EIWORK, pp_SOVTOLL_EINONWORK</li>
        <li>pp_HOV2HOV_EIWORK, pp_HOV2HOV_EINONWORK, pp_HOV2TOLL_EIWORK, pp_HOV2TOLL_EINONWORK</li>
        <li>pp_HOV3HOV_EIWORK, pp_HOV3HOV_EINONWORK, pp_HOV3TOLL_EIWORK, pp_HOV3TOLL_EINONWORK</li>
    </ul>
    to the time-of-day total demand matrices.
    <br>
</div>
        """
        pb.branding_text = "- SANDAG - Model"

        if self.tool_run_msg != "":
            pb.tool_run_status(self.tool_run_msg_status)
        pb.add_select_file('output_dir', 'directory',
                           title='Select output directory')
        pb.add_text_box("external_zones", title="External zones:")
        dem_utils.add_select_processors("num_processors", pb, self)
        return pb.render()

    def run(self):
        self.tool_run_msg = ""
        try:
            scenario = _m.Modeller().scenario
            self(self.output_dir, self.external_zones, self.num_processors, scenario)
            run_msg = "Tool completed"
            self.tool_run_msg = _m.PageBuilder.format_info(run_msg, escape=False)
        except Exception as error:
            self.tool_run_msg = _m.PageBuilder.format_exception(
                error, _traceback.format_exc(error))
            raise

    @_m.logbook_trace("Create TOD auto trip tables", save_arguments=True)
    def __call__(self, output_dir, external_zones, num_processors, scenario):
        attributes = {
            "output_dir": output_dir, 
            "external_zones": external_zones, 
            "num_processors": num_processors}
        gen_utils.log_snapshot("Create TOD auto trip tables", str(self), attributes)
        
        #get parameters from sandag_abm.properties
        modeller = _m.Modeller()
        load_properties = modeller.tool('sandag.utilities.properties')
        props = load_properties(_join(self.main_dir, "conf", "sandag_abm.properties"))
        cvm_scale_factor = props["cvm.scale_factor"]
        cvm_scale_light = props["cvm.scale_light"]
        cvm_scale_medium = props["cvm.scale_medium"]
        cvm_scale_heavy = props["cvm.scale_heavy"]
        cvm_share_light = props["cvm.share.light"]
        cvm_share_medium = props["cvm.share.medium"]
        cvm_share_heavy = props["cvm.share.heavy"]
        taxi_da_share = props["Taxi.da.share"]
        taxi_s2_share = props["Taxi.s2.share"]
        taxi_s3_share = props["Taxi.s3.share"]
        taxi_pce = props["Taxi.passengersPerVehicle"]
        tnc_single_da_share = props["TNC.single.da.share"]
        tnc_single_s2_share = props["TNC.single.s2.share"]
        tnc_single_s3_share = props["TNC.single.s3.share"]
        tnc_single_pce = props["TNC.single.passengersPerVehicle"]        
        tnc_shared_da_share = props["TNC.shared.da.share"]
        tnc_shared_s2_share = props["TNC.shared.s2.share"]
        tnc_shared_s3_share = props["TNC.shared.s3.share"]
        tnc_shared_pce = props["TNC.shared.passengersPerVehicle"]          

        self.scenario = scenario
        self.output_dir = output_dir
        self.external_zones = external_zones
        self.num_processors = num_processors
        self.import_traffic_trips(taxi_da_share,taxi_s2_share,taxi_s3_share,taxi_pce,
                                  tnc_single_da_share,tnc_single_s2_share,tnc_single_s3_share,tnc_single_pce,
                                  tnc_shared_da_share,tnc_shared_s2_share,tnc_shared_s3_share,tnc_shared_pce)
        self.import_commercial_vehicle_demand(cvm_scale_factor,cvm_scale_light,cvm_scale_medium,cvm_scale_heavy,cvm_share_light,cvm_share_medium,cvm_share_heavy)
        #self.convert_light_trucks_to_pce()
        self.add_aggregate_demand()

    @_m.logbook_trace("Import CT-RAMP traffic trips from OMX")
    def import_traffic_trips(self, taxi_da_share, taxi_s2_share, taxi_s3_share, taxi_pce,
                                  tnc_single_da_share, tnc_single_s2_share, tnc_single_s3_share, tnc_single_pce,
                                  tnc_shared_da_share, tnc_shared_s2_share, tnc_shared_s3_share, tnc_shared_pce):
        emmebank = self.scenario.emmebank
        periods = ["EA", "AM", "MD", "PM", "EV"]
        other_matrix_name_tmplts = [
            ("mf%s_SOV_NT_%s",  "SOV_GP_%s"),
            ("mf%s_SOV_TR_%s",  "SOV_PAY_%s"),
            ("mf%s_HOV2_%s",    "SR2_NOPAY_%s"),
            ("mf%s_HOV3_%s",    "SR3_NOPAY_%s")]

        matrix_name_tmplts = [
            ("mf%s_SOV_NT_%s",  "SOV_PAYNOTRPDR_%s"),
            ("mf%s_SOV_TR_%s",  "SOV_PAYTRPDR_%s"),
            ("mf%s_HOV2_%s",    "SR2_CHOICE_%s"),
            ("mf%s_HOV3_%s",    "SR3_CHOICE_%s")]
        
        #other (taxi/tnc) demand go into toll and high VOT
        parameter_name_tmplts = {
            "mf%s_SOV_TR_%s": {"TAXI": taxi_da_share,"TNC_SINGLE": tnc_single_da_share,"TNC_SHARED": tnc_shared_da_share},
            "mf%s_HOV2_%s": {"TAXI": taxi_s2_share,"TNC_SINGLE": tnc_single_s2_share,"TNC_SHARED": tnc_shared_s2_share},
            "mf%s_HOV3_%s": {"TAXI": taxi_s3_share,"TNC_SINGLE": tnc_single_s3_share,"TNC_SHARED": tnc_shared_s3_share}
        }
                      
        matrix_names = []
        parameter_names = {}
        for vot_bin in ["low", "med", "high"]:
            vot = vot_bin[0].upper()
            for period in periods:
                for emme_name, omx_name in matrix_name_tmplts:
                    matrix_names.append(("_" + period, vot_bin, emme_name % (period, vot), omx_name % (period)))
                for emme_name in parameter_name_tmplts:
                    key = emme_name % (period, vot)
                    value = parameter_name_tmplts[emme_name]
                    parameter_names[key] = value
                    
        # TR and NT segmentation for non-residents (Joel email - Oct 22nd 2019):
        # crossborder - DO NOT have transponder (all SOV into SOVNT)
        # visitors - DO NOT have transponder
        # Internal-Extrnal - DO have transponder (all SOV into SOVTR)
        # Airport - DO have transponder
        # External - DO have transponder
            
        with gen_utils.OMXManager(self.output_dir, "auto%sTrips%s_%s.omx") as omx_manager, gen_utils.OMXManager(self.output_dir, "othr%sTrips%s.omx") as omx_manager_othr:
            for period, vot_bin, matrix_name, omx_key in matrix_names:
                logbook_label = "Import from OMX key %s to matrix %s" % (omx_key, matrix_name)
                
                if "SOV" in omx_key: #SOV classes
                    person_demand = omx_manager.lookup(("", period, vot_bin), omx_key)
                    person_demand += omx_manager.lookup(("", period, vot_bin), omx_key.replace("PAY","GP"))
                    
                    array_zeros = numpy.zeros((4996,4996))
                    #cross-border and visitor demand
                    if "NT" not in matrix_name:
                        visitor_demand = array_zeros
                        cross_border_demand = array_zeros

                        #airport and internal-external demand - doesn't have transponder segmentation
                        #assume they DO have transponder
                        #all SOV go to SOVTP
                        airport_demand = omx_manager.lookup(("Airport", ".SAN" + period, vot_bin), omx_key.replace("PAYTRPDR","GP"))
                        if omx_manager.file_exists(("Airport", ".CBX" + period, vot_bin)):
                            airport_demand += omx_manager.lookup(("Airport", ".CBX" + period, vot_bin), omx_key.replace("PAYTRPDR","GP"))
                        internal_external_demand = omx_manager.lookup(("InternalExternal", period, vot_bin), omx_key.replace("PAYTRPDR","GP"))
                        
                        airport_demand += omx_manager.lookup(("Airport", ".SAN" + period, vot_bin), omx_key.replace("PAYTRPDR","PAY"))
                        if omx_manager.file_exists(("Airport", ".CBX" + period, vot_bin)):
                            airport_demand += omx_manager.lookup(("Airport", ".CBX" + period, vot_bin), omx_key.replace("PAYTRPDR","PAY"))
                        
                        internal_external_demand += omx_manager.lookup(("InternalExternal", period, vot_bin), omx_key.replace("PAYTRPDR","PAY"))

                    else:
                        visitor_demand = omx_manager.lookup(("Visitor", period, vot_bin), omx_key.replace("PAYNOTRPDR","GP"))
                        cross_border_demand = omx_manager.lookup(("CrossBorder", period, vot_bin), omx_key.replace("PAYNOTRPDR","GP"))

                        #add the GP demand as well - doesn't have transponder segmentation
                        #assume they DO NOT have transpnder
                        #all SOV demand go to SOVNTP
                        visitor_demand = omx_manager.lookup(("Visitor", period, vot_bin), omx_key.replace("PAYNOTRPDR","GP"))
                        cross_border_demand = omx_manager.lookup(("CrossBorder", period, vot_bin), omx_key.replace("PAYNOTRPDR","GP"))

                        visitor_demand += omx_manager.lookup(("Visitor", period, vot_bin), omx_key.replace("PAYNOTRPDR","PAY"))
                        cross_border_demand += omx_manager.lookup(("CrossBorder", period, vot_bin), omx_key.replace("PAYNOTRPDR","PAY"))
                        
                        airport_demand = array_zeros
                        internal_external_demand = array_zeros
                    
                else: #SR2 and SR3
                    for toll_bin in ["PAY", "NOPAY"]:
                        #for resident model - transponder segmentation
                        for tp_bin in ["TRPDR", "NOTRPDR"]:
                            choice = toll_bin + tp_bin
                            if ((toll_bin=="PAY") and (tp_bin=="TRPDR")):  #first choice 
                                person_demand = omx_manager.lookup(("", period, vot_bin), omx_key.replace("CHOICE", choice))
                            else:                    
                                person_demand += omx_manager.lookup(("", period, vot_bin), omx_key.replace("CHOICE", choice))
                                
                        #non-resident models do not have transpnder segmentation
                        if (toll_bin=="PAY"):
                            visitor_demand = omx_manager.lookup(("Visitor", period, vot_bin), omx_key.replace("CHOICE", toll_bin))
                            cross_border_demand = omx_manager.lookup(("CrossBorder", period, vot_bin), omx_key.replace("CHOICE", toll_bin))
                            airport_demand = omx_manager.lookup(("Airport", ".SAN" + period, vot_bin), omx_key.replace("CHOICE", toll_bin))
                            if omx_manager.file_exists(("Airport", ".CBX" + period, vot_bin)):
                                airport_demand += omx_manager.lookup(("Airport", ".CBX" + period, vot_bin), omx_key.replace("CHOICE", toll_bin))                               
                            internal_external_demand = omx_manager.lookup(("InternalExternal", period, vot_bin), omx_key.replace("CHOICE", toll_bin))
                        else:
                            visitor_demand += omx_manager.lookup(("Visitor", period, vot_bin), omx_key.replace("CHOICE", toll_bin))
                            cross_border_demand += omx_manager.lookup(("CrossBorder", period, vot_bin), omx_key.replace("CHOICE", toll_bin))
                            airport_demand += omx_manager.lookup(("Airport", ".SAN" + period, vot_bin), omx_key.replace("CHOICE", toll_bin))
                            if omx_manager.file_exists(("Airport", ".CBX" + period, vot_bin)):
                                airport_demand += omx_manager.lookup(("Airport", ".CBX" + period, vot_bin), omx_key.replace("CHOICE", toll_bin))
                            
                            internal_external_demand += omx_manager.lookup(("InternalExternal", period, vot_bin), omx_key.replace("CHOICE", toll_bin))

                #add other trips (TAXI and TNC) to HIGH vot and TOLL group. 
                #Convert to vehicle trips by using factor for occupancy.
                #not adding SCHLBUS for now
                if ((vot_bin == "high") and ("NT" not in matrix_name)):
                    #resident
                    person_taxi_demand = omx_manager_othr.lookup(("",period),"TAXI"+period) * (parameter_names[matrix_name]["TAXI"]/taxi_pce)
                    person_tnc_single_demand = omx_manager_othr.lookup(("",period),"TNC_SINGLE"+period) * (parameter_names[matrix_name]["TNC_SINGLE"]/tnc_single_pce )
                    person_tnc_shared_demand = omx_manager_othr.lookup(("",period),"TNC_SHARED"+period) * (parameter_names[matrix_name]["TNC_SHARED"]/tnc_shared_pce)
                    person_othr_demand = person_taxi_demand + person_tnc_single_demand + person_tnc_shared_demand
                    #visitor
                    visitor_taxi_demand = omx_manager_othr.lookup(("Visitor",period),"TAXI"+period) * (parameter_names[matrix_name]["TAXI"]/taxi_pce)
                    visitor_tnc_single_demand = omx_manager_othr.lookup(("Visitor",period),"TNC_SINGLE"+period) * (parameter_names[matrix_name]["TNC_SINGLE"]/tnc_single_pce )
                    visitor_tnc_shared_demand = omx_manager_othr.lookup(("Visitor",period),"TNC_SHARED"+period) * (parameter_names[matrix_name]["TNC_SHARED"]/tnc_shared_pce)
                    visitor_othr_demand = visitor_taxi_demand + visitor_tnc_single_demand + visitor_tnc_shared_demand
                    #cross border
                    cross_border_taxi_demand = omx_manager_othr.lookup(("CrossBorder",period),"TAXI"+period) * (parameter_names[matrix_name]["TAXI"]/taxi_pce)
                    cross_border_tnc_single_demand = omx_manager_othr.lookup(("CrossBorder",period),"TNC_SINGLE"+period) * (parameter_names[matrix_name]["TNC_SINGLE"]/tnc_single_pce )
                    cross_border_tnc_shared_demand = omx_manager_othr.lookup(("CrossBorder",period),"TNC_SHARED"+period) * (parameter_names[matrix_name]["TNC_SHARED"]/tnc_shared_pce)
                    cross_border_othr_demand = cross_border_taxi_demand + cross_border_tnc_single_demand + cross_border_tnc_shared_demand                                       
                    #airport SAN
                    airport_taxi_demand = omx_manager_othr.lookup(("Airport",".SAN" + period),"TAXI"+period) * (parameter_names[matrix_name]["TAXI"]/taxi_pce)
                    airport_tnc_single_demand = omx_manager_othr.lookup(("Airport",".SAN" + period),"TNC_SINGLE"+period) * (parameter_names[matrix_name]["TNC_SINGLE"]/tnc_single_pce )
                    airport_tnc_shared_demand = omx_manager_othr.lookup(("Airport",".SAN" + period),"TNC_SHARED"+period) * (parameter_names[matrix_name]["TNC_SHARED"]/tnc_shared_pce)
                    #airport CBX
                    airport_taxi_demand += omx_manager_othr.lookup(("Airport",".CBX" + period),"TAXI"+period) * (parameter_names[matrix_name]["TAXI"]/taxi_pce)
                    airport_tnc_single_demand += omx_manager_othr.lookup(("Airport",".CBX" + period),"TNC_SINGLE"+period) * (parameter_names[matrix_name]["TNC_SINGLE"]/tnc_single_pce )
                    airport_tnc_shared_demand += omx_manager_othr.lookup(("Airport",".CBX" + period),"TNC_SHARED"+period) * (parameter_names[matrix_name]["TNC_SHARED"]/tnc_shared_pce)
                    airport_othr_demand = airport_taxi_demand + airport_tnc_single_demand + airport_tnc_shared_demand
                    #internal external
                    internal_external_taxi_demand = omx_manager_othr.lookup(("InternalExternal",period),"TAXI"+period) * (parameter_names[matrix_name]["TAXI"]/taxi_pce)
                    internal_external_tnc_single_demand = omx_manager_othr.lookup(("InternalExternal",period),"TNC_SINGLE"+period) * (parameter_names[matrix_name]["TNC_SINGLE"]/tnc_single_pce )
                    internal_external_tnc_shared_demand = omx_manager_othr.lookup(("InternalExternal",period),"TNC_SHARED"+period) * (parameter_names[matrix_name]["TNC_SHARED"]/tnc_shared_pce)
                    internal_external_othr_demand = internal_external_taxi_demand + internal_external_tnc_single_demand + internal_external_tnc_shared_demand                    
                    #total trips
                    total_ct_ramp_trips = (
                        visitor_demand + cross_border_demand + airport_demand
                        + person_demand + internal_external_demand + person_othr_demand
                        + visitor_othr_demand + cross_border_othr_demand + airport_othr_demand 
                        + internal_external_othr_demand)
                    
                else:
                    total_ct_ramp_trips = (
                        visitor_demand + cross_border_demand + airport_demand
                        + person_demand + internal_external_demand)
                        
                if ((vot_bin == "high")  and ("NT" not in matrix_name)):
                    dem_utils.demand_report([
                        ("person_demand", person_demand),
                        ("internal_external_demand", internal_external_demand),
                        ("cross_border_demand", cross_border_demand),
                        ("airport_demand", airport_demand),
                        ("visitor_demand", visitor_demand),
                        ("person_other_demand", person_othr_demand),
                        ("visitor_other_demand", visitor_othr_demand),
                        ("cross_border_other_demand", cross_border_othr_demand),
                        ("airport_other_demand", airport_othr_demand),
                        ("internal_external_other_demand", internal_external_othr_demand),
                        ("total_ct_ramp_trips", total_ct_ramp_trips)
                    ], logbook_label, self.scenario)
                else:
                    dem_utils.demand_report([
                        ("person_demand", person_demand),
                        ("internal_external_demand", internal_external_demand),
                        ("cross_border_demand", cross_border_demand),
                        ("airport_demand", airport_demand),
                        ("visitor_demand", visitor_demand),
                        ("total_ct_ramp_trips", total_ct_ramp_trips)
                    ], logbook_label, self.scenario)

                matrix = emmebank.matrix(matrix_name)
                matrix.set_numpy_data(total_ct_ramp_trips, self.scenario)
                

    @_m.logbook_trace('Import commercial vehicle demand')
    def import_commercial_vehicle_demand(self, scale_factor, scale_light, scale_medium, scale_heavy, share_light, share_medium, share_heavy):
        scenario = self.scenario
        emmebank = scenario.emmebank
        
        mapping = {}
        periods = ["EA", "AM", "MD", "PM", "EV"]
        # The SOV demand is modified in-place, which was imported 
        # prior from the CT-RAMP demand
        # The truck demand in vehicles is copied from separate matrices
        for index, period in enumerate(periods):
            for cvm_acc, trnspdr in [("T", "TR"), ("NT", "NT")]:
                mapping["CVM_%s:L%s" % (period, cvm_acc)] = {
                    "orig": "%s_SOV_%s_H" % (period, trnspdr), 
                    "dest": "%s_SOV_%s_H" % (period, trnspdr), 
                    "pce": 1.0,
                    "scale": scale_light[index],
                    "share": share_light,
                    "period": period,
                    "cvm_acc": cvm_acc
                }
                mapping["CVM_%s:I%s" % (period, cvm_acc)] = {
                    "orig": "%s_TRK_L_VEH" % (period),
                    "dest": "%s_TRK_L" % (period), 
                    "pce": 1.3,
                    "scale": scale_medium[index],
                    "share": share_medium,
                    "period": period,
                    "cvm_acc": cvm_acc
                }
                mapping["CVM_%s:M%s" % (period, cvm_acc)] = {
                    "orig": "%s_TRK_M_VEH" % (period),
                    "dest": "%s_TRK_M" % (period), 
                    "pce": 1.5,
                    "scale": scale_medium[index],
                    "share": share_medium,
                    "period": period,
                    "cvm_acc": cvm_acc
                }
                mapping["CVM_%s:H%s" % (period, cvm_acc)] = {
                    "orig": "%s_TRK_H_VEH" % (period),
                    "dest": "%s_TRK_H" % (period), 
                    "pce": 2.5,
                    "scale": scale_heavy[index],
                    "share": share_heavy,
                    "period": period,
                    "cvm_acc": cvm_acc
                }
        with _m.logbook_trace('Load starting SOV and truck matrices'):
            for key, value in mapping.iteritems():
                value["array"] = emmebank.matrix(value["orig"]).get_numpy_data(scenario)
        
        with _m.logbook_trace('Processing CVM from TripMatrices.csv'):
            path = os.path.join(self.output_dir, "TripMatrices.csv")
            table = _pandas.read_csv(path)
            for key, value in mapping.iteritems():
                cvm_array = table[key].values.reshape((4996, 4996))     # reshape method deprecated since v 0.19.0, yma, 2/12/2019
                #factor in cvm demand by the scale factor used in trip generation
                cvm_array = cvm_array/scale_factor
                #scale trips to take care of underestimation
                cvm_array = cvm_array * value["scale"]
                
                #add remaining share to the correspnding truck matrix
                value["array"] = value["array"] + (cvm_array * (1-value["share"]))
                
            #add cvm truck vehicles to light-heavy trucks
            for key, value in mapping.iteritems():
                period = value["period"]
                cvm_acc = value["cvm_acc"]
                cvm_vehs = ['L','M','H']
                if key == "CVM_%s:I%s" % (period, cvm_acc):
                    for veh in cvm_vehs:
                        key_new = "CVM_%s:%s%s" % (period, veh, cvm_acc)
                        value_new = mapping[key_new]
                        if value_new["share"] != 0.0:
                            cvm_array = table[key_new].values.reshape((4996, 4996))
                            cvm_array = cvm_array/scale_factor
                            cvm_array = cvm_array * value_new["scale"]
                            value["array"] = value["array"] + (cvm_array * value_new["share"])
        matrix_unique = {}          
        with _m.logbook_trace('Save SOV matrix and convert CV and truck vehicle demand to PCEs for assignment'):
            for key, value in mapping.iteritems():
                matrix = emmebank.matrix(value["dest"])
                array = value["array"]
                #if value["pce"] != 1.0:
                array = array * value["pce"]

                if (matrix in matrix_unique.keys()):
                    array = array + emmebank.matrix(value["dest"]).get_numpy_data(scenario)
                
                matrix.set_numpy_data(array, scenario)
                matrix_unique[matrix] = 1

    @_m.logbook_trace('Convert light truck vehicle demand to PCEs for assignment')
    def convert_light_trucks_to_pce(self):
        matrix_calc = dem_utils.MatrixCalculator(self.scenario, self.num_processors)
        # Calculate PCEs for trucks
        periods = ["EA", "AM", "MD", "PM", "EV"]
        mat_trucks = ['TRK_L']
        pce_values = [1.3]
        for period in periods:
            with matrix_calc.trace_run("Period %s" % period):
                for name, pce in zip(mat_trucks, pce_values):
                    demand_name = 'mf%s_%s' % (period, name)
                    matrix_calc.add(demand_name, '(%s_VEH * %s).max.0' % (demand_name, pce))

    @_m.logbook_trace('Add aggregate demand')
    def add_aggregate_demand(self):
        matrix_calc = dem_utils.MatrixCalculator(self.scenario, self.num_processors)
        periods = ["EA", "AM", "MD", "PM", "EV"]
        vots = ["L", "M", "H"]
        # Extern-internal trips DO have transponder
        # all SOV trips go to SOVTP
        with matrix_calc.trace_run("Add external-internal trips to auto demand"):
            modes = ["SOVGP", "SOVTOLL", "HOV2HOV", "HOV2TOLL", "HOV3HOV", "HOV3TOLL"]
            mdoes_assign = {"SOVGP":    "SOV_TR",
                            "SOVTOLL":  "SOV_TR",
                            "HOV2HOV":  "HOV2",
                            "HOV2TOLL": "HOV2",
                            "HOV3HOV":  "HOV3",
                            "HOV3TOLL": "HOV3"}
            
            for period in periods:
                for mode in modes:
                    for vot in vots:
                        # Segment imported demand into 3 equal parts for VOT Low/Med/High
                        assign_mode = mdoes_assign[mode]
                        params = {'p': period, 'm': mode, 'v': vot, 'am': assign_mode}
                        matrix_calc.add("mf%s_%s_%s" % (period, assign_mode, vot),
                             "mf%(p)s_%(am)s_%(v)s "
                             "+ (1.0/3.0)*mf%(p)s_%(m)s_EIWORK "
                             "+ (1.0/3.0)*mf%(p)s_%(m)s_EINONWORK" % params)

        # External - external faster with single-processor as number of O-D pairs is so small (12 X 12)
        # External-external trips do not have transpnder
        # all SOV trips go to SOVNTP
        matrix_calc.num_processors = 0
        with matrix_calc.trace_run("Add external-external trips to auto demand"):
            modes = ["SOV", "HOV2", "HOV3"]
            for period in periods:
                for mode in modes:
                    for vot in vots:
                        # Segment imported demand into 3 equal parts for VOT Low/Med/High
                        params = {'p': period, 'm': mode, 'v': vot}
                        if (mode == "SOV"):
                            matrix_calc.add(
                                "mf%(p)s_%(m)s_NT_%(v)s" % params,
                                "mf%(p)s_%(m)s_NT_%(v)s + (1.0/3.0)*mf%(p)s_%(m)s_EETRIPS" % params,
                                {"origins": self.external_zones, "destinations": self.external_zones})
                        else:
                            matrix_calc.add(
                                "mf%(p)s_%(m)s_%(v)s" % params,
                                "mf%(p)s_%(m)s_%(v)s + (1.0/3.0)*mf%(p)s_%(m)s_EETRIPS" % params,
                                {"origins": self.external_zones, "destinations": self.external_zones})
